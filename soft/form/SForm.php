<?phpnamespace soft\form;use Yii;use kartik\builder\Form;use kartik\helpers\Html;use soft\db\SActiveRecord;use soft\helpers\SArray;use soft\service\InputType;use yii\base\InvalidConfigException;class SForm extends Form{    const INPUT_STATUS = 'status';    const INPUT_ELFINDER = 'elfinder';    const INPUT_CKEDITOR = 'ckeditor';    const INPUT_ICON = 'icon';    const INPUT_CROPPER = 'cropper';    const INPUT_SELECT2 = 'select2';    protected static $_widgetInputs = [        self::INPUT_STATUS => true,        self::INPUT_ELFINDER => true,        self::INPUT_CKEDITOR => true,        self::INPUT_ICON => true,        self::INPUT_CROPPER => true,        self::INPUT_SELECT2 => true,    ];    /**     * @var SActiveRecord the model instance.     */    public $model;    public $attributeDefaults = ['type' => Form::INPUT_TEXT];    public function init()    {        $this->attributes = $this->generateAttributes($this->attributes);        parent::init();    }    protected function generateAttributes($attributes = [])    {        $result = [];        foreach ($attributes as $key => $setting) {            if (SArray::getValue($setting, 'visible', true) === true) {                if (isset($setting['attributes'])) {                    $result[$key] = $setting;                    $result[$key]['attributes'] = $this->generateAttributes($setting['attributes']);                } else {                    $this->generateFormattedConfigs($result, $key, $setting);                }            }        }        return $result;    }    public function generateFormattedConfigs(&$result, $key, $setting)    {        $configs = [];        if (is_array($setting)) {            $formattedConfigs = $this->formattedConfigs($key);        } else {            $formattedConfigs = $this->formattedConfigs($setting);        }        $key = $formattedConfigs['attribute'];        if ($formattedConfigs['type'] != null) {            $configs['type'] = $formattedConfigs['type'];        }        $configs['label'] = $formattedConfigs['label'];        if (is_array($setting)) {            $configs = SArray::merge($configs, $setting);        }        $result[$key] = $this->generateConfigs($key, $configs);    }    /**     * Kartik FormBuilder uchun configni generatsiya qilish     * $customConfigs - bu SForm builderni generatsiya qilayotganda user tomonidan     * berilgan configlar     */    public function generateConfigs($attribute, $customConfigs = [])    {        $defaultAttributeConfigs = SArray::getValue($this->defaultAttributeConfigs(), $attribute, []);        $configs = SArray::merge($defaultAttributeConfigs, $customConfigs);        $type = SArray::getValue($configs, 'type', self::INPUT_TEXT);        if (isset(static::$_widgetInputs[$type])) {            $defaultInputTypeOptions = static::defaultInputTypeOptions($type);            $configs = SArray::merge($defaultInputTypeOptions, $customConfigs);            $configs['type'] = self::INPUT_WIDGET;        }        return $configs;    }    protected function getSubAttributesContent($settings, $index)    {        $subIndex = 0;        $defaultSubColOptions = SArray::getValue($settings, 'subColumnOptions', $this->columnOptions);        $content = '';        $content .= "\t" . $this->beginTag('div', $this->rowOptions) . "\n";        $attrCount = count($settings['attributes']);        $cols = SArray::getValue($settings, 'columns', $attrCount);        foreach ($settings['attributes'] as $subAttr => $subSettings) {            $subColWidth = (int)(self::GRID_WIDTH / $cols);            $subSettings = array_replace_recursive($this->attributeDefaults, $subSettings);            $subColOptions = SArray::getValue($subSettings, 'columnOptions', $defaultSubColOptions);            if (isset($subColOptions['colspan'])) {                $subColWidth = (int)$subColWidth * (int)($subColOptions['colspan']);                unset($subColOptions['colspan']);            }            Html::addCssClass($subColOptions, 'col-' . $this->columnSize . '-' . $subColWidth);            $subSettings['columnOptions'] = $subColOptions;            $subSettings['fieldConfig']['skipFormLayout'] = true;            $content .= "\t\t" . $this->beginTag('div', $subColOptions) . "\n";            /** @var integer $index */            $content .= "\t\t\t" . $this->parseInput($subAttr, $subSettings, $index * 10 + $subIndex) . "\n";            $subIndex++;            $content .= "\t\t" . $this->endTag('div') . "\n";        }        $content .= "\t" . $this->endTag('div') . "\n";        return $content;    }    protected static function defaultInputTypeOptions($type)    {        switch ($type) {            case self::INPUT_STATUS:                return [                    'widgetClass' => InputType::SWITCH,                    'options' => [                        'pluginOptions' => [                            'onText' => 'Faol',                            'offText' => 'Nofaol',                        ],                    ],                ];            case self::INPUT_ELFINDER:                return [                    'type' => InputType::WIDGET,                    'widgetClass' => '\mihaildev\elfinder\InputFile',                    'options' => [                        'language' => 'ru',                        'controller' => 'elfinder',                        'filter' => 'image',                        'template' => '<div class="input-group">{input}<span class="input-group-btn">{button}</span></div>',                        'options' => ['class' => 'form-control'],                        'buttonOptions' => ['class' => 'btn btn-primary'],                        'multiple' => false,                    ]                ];            case self::INPUT_CKEDITOR:                return [                    'type' => InputType::WIDGET,                    'widgetClass' => '\mihaildev\ckeditor\CKEditor',                ];            case self::INPUT_ICON:                return [                    'type' => InputType::WIDGET,                    'widgetClass' => '\dominus77\iconpicker\IconPicker',                ];            case self::INPUT_CROPPER:                return [                    'type' => InputType::WIDGET,                    'widgetClass' => '\odilov\cropper\Cropper',                ];                case self::INPUT_SELECT2:                return [                    'type' => InputType::WIDGET,                    'widgetClass' => '\kartik\widgets\Select2' ,                    'options' => [                        'pluginOptions' => [                            'placeholder' => 'Tanlang ...',                            'allowClear' => true,                        ]                    ]                ];            default:                return [];        }    }    protected function defaultAttributeConfigs()    {        return [            'status' => [                'type' => self::INPUT_STATUS,            ],            'password' => [                'type' => self::INPUT_PASSWORD,            ],        ];    }    protected function formattedConfigs($attribute)    {        if (!preg_match('/^([^:]+)(:(\w*))?(:(.*))?$/', $attribute, $matches)) {            throw new InvalidConfigException('The attribute must be specified in the format of "attribute", "attribute:format" or "attribute:format:label"');        }        return [            'attribute' => $matches[1],            'type' => isset($matches[3]) ? $matches[3] : null,            'label' => isset($matches[5]) ? $matches[5] : null,        ];    }}?>